{% extends "base.html" %}
{% block title %}Take Attendance - AttendAI{% endblock %}

{% block extra_head %}
<style>
    .camera-container {
        position: relative;
        border-radius: 1.5rem;
        overflow: hidden;
        background: #000;
        aspect-ratio: 4/3;
    }
    @media (min-width: 768px) {
        .camera-container {
            aspect-ratio: 16/9;
        }
    }
    .camera-container video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    .camera-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
    .pulse-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(1.2); }
    }
    .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        transition: all 0.3s ease;
    }
    .btn-primary:hover {
        opacity: 0.9;
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }
    .btn-primary:disabled {
        opacity: 0.5;
        transform: none;
        box-shadow: none;
        cursor: not-allowed;
    }
    .student-card {
        animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(-10px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="max-w-3xl mx-auto">
    
    <!-- Header -->
    <div class="text-center mb-6">
        <h1 class="text-2xl sm:text-3xl font-bold text-slate-800 mb-2">üì∑ Face Recognition</h1>
        <p class="text-slate-500">Point camera at students to mark attendance</p>
    </div>

    <!-- Camera Section -->
    <div class="bg-white rounded-3xl shadow-xl overflow-hidden mb-6">
        
        <!-- Camera Select (Minimal) -->
        <div class="px-4 py-3 border-b border-slate-100 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div id="statusDot" class="pulse-dot bg-slate-400"></div>
                <span id="cameraStatus" class="text-sm font-medium text-slate-600">Select Camera</span>
            </div>
            <select id="cameraSelect" class="text-sm bg-slate-100 border-0 rounded-full px-3 py-1.5 focus:ring-2 focus:ring-indigo-500 cursor-pointer">
                <option value="">Loading...</option>
            </select>
        </div>
        
        <!-- Camera Preview -->
        <div class="camera-container">
            <video id="videoPreview" autoplay playsinline muted></video>
            <canvas id="canvasOverlay"></canvas>
            
            <!-- Scanning Indicator -->
            <div id="scanningBadge" class="hidden absolute top-4 left-4 bg-red-500 text-white px-3 py-1 rounded-full text-sm font-semibold flex items-center gap-2">
                <div class="w-2 h-2 bg-white rounded-full animate-pulse"></div>
                LIVE
            </div>
            
            <!-- Count Badge -->
            <div class="absolute top-4 right-4 bg-black/60 backdrop-blur text-white px-4 py-2 rounded-full">
                <span class="font-bold text-lg" id="detectedCount">0</span>
                <span class="text-white/80 text-sm"> detected</span>
            </div>
            
            <!-- Placeholder when camera off -->
            <div id="cameraPlaceholder" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900 text-white">
                <span class="text-6xl mb-4">üì∑</span>
                <p class="text-slate-400">Tap "Start Scanning" to begin</p>
            </div>
        </div>
        
        <!-- Hidden capture canvas -->
        <canvas id="captureCanvas" class="hidden"></canvas>
        
        <!-- Control Buttons -->
        <div class="p-4 grid grid-cols-2 gap-3">
            <button id="startBtn" class="btn-primary text-white font-semibold py-3.5 px-6 rounded-xl flex items-center justify-center gap-2">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                Start Scanning
            </button>
            <button id="stopBtn" class="bg-slate-200 text-slate-700 font-semibold py-3.5 px-6 rounded-xl flex items-center justify-center gap-2 hover:bg-slate-300 transition-all disabled:opacity-50" disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"></path>
                </svg>
                Stop
            </button>
        </div>
    </div>

    <!-- Status Alert -->
    <div id="statusMessage" class="hidden mb-6 p-4 rounded-2xl font-medium text-center"></div>

    <!-- Detected Students -->
    <div class="bg-white rounded-3xl shadow-xl overflow-hidden mb-6">
        <div class="px-5 py-4 border-b border-slate-100 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <span class="text-xl">üë•</span>
                <h2 class="font-bold text-slate-800">Detected Students</h2>
            </div>
            <span class="bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full text-sm font-bold" id="totalDetected">0</span>
        </div>
        
        <div id="detectedList" class="p-4 max-h-80 overflow-y-auto space-y-2">
            <div class="text-center py-8 text-slate-400">
                <span class="text-4xl mb-2 block">üîç</span>
                <p>No students detected yet</p>
                <p class="text-sm mt-1">Start scanning to recognize faces</p>
            </div>
        </div>
    </div>

    <!-- Actions -->
    <div class="grid grid-cols-2 gap-4 mb-8">
        <button id="finalizeBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-6 rounded-2xl transition-all flex items-center justify-center gap-2 shadow-lg hover:shadow-xl">
            <span class="text-xl">üíæ</span>
            Save to DB
        </button>
        <button id="resetBtn" class="bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-4 px-6 rounded-2xl transition-all flex items-center justify-center gap-2">
            <span class="text-xl">üîÑ</span>
            Reset
        </button>
    </div>

    <!-- Tips -->
    <div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-2xl p-5 border border-indigo-100">
        <h3 class="font-bold text-slate-800 mb-3 flex items-center gap-2">
            <span>üí°</span> Tips for Best Results
        </h3>
        <ul class="text-sm text-slate-600 space-y-2">
            <li class="flex items-start gap-2">
                <span class="text-green-500">‚úì</span>
                Ensure good lighting on faces
            </li>
            <li class="flex items-start gap-2">
                <span class="text-green-500">‚úì</span>
                Hold camera steady for 2-3 seconds
            </li>
            <li class="flex items-start gap-2">
                <span class="text-green-500">‚úì</span>
                Keep faces clearly visible, no obstructions
            </li>
            <li class="flex items-start gap-2">
                <span class="text-green-500">‚úì</span>
                Use back camera for better quality
            </li>
        </ul>
    </div>
</div>

<script>
    // Elements
    const videoPreview = document.getElementById('videoPreview');
    const captureCanvas = document.getElementById('captureCanvas');
    const canvasOverlay = document.getElementById('canvasOverlay');
    const cameraSelect = document.getElementById('cameraSelect');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const finalizeBtn = document.getElementById('finalizeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const cameraStatus = document.getElementById('cameraStatus');
    const statusDot = document.getElementById('statusDot');
    const detectedCount = document.getElementById('detectedCount');
    const totalDetected = document.getElementById('totalDetected');
    const detectedList = document.getElementById('detectedList');
    const statusMessage = document.getElementById('statusMessage');
    const scanningBadge = document.getElementById('scanningBadge');
    const cameraPlaceholder = document.getElementById('cameraPlaceholder');

    // State
    let stream = null;
    let isScanning = false;
    let ctx = captureCanvas.getContext('2d');
    let overlayCtx = canvasOverlay.getContext('2d');
    let sentFrameWidth = 0;
    let sentFrameHeight = 0;
    let lastProcessingTime = 0;
    let isProcessing = false;  // Prevent overlapping requests
    
    // SUPER-FAST Configuration - minimal latency
    const BASE_SCAN_INTERVAL_MS = 300;  // Fast base interval
    const MIN_SCAN_INTERVAL_MS = 200;   // Minimum 200ms between scans
    const MAX_SCAN_INTERVAL_MS = 1000;  // Max 1 second
    const FRAME_QUALITY = 0.6;  // Lower quality = smaller data = faster upload
    const MAX_FRAME_WIDTH = 640;  // Smaller frame = faster processing
    let currentInterval = BASE_SCAN_INTERVAL_MS;

    // Initialize camera list
    async function initCameraList() {
        try {
            const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
            tempStream.getTracks().forEach(track => track.stop());
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(d => d.kind === 'videoinput');
            
            cameraSelect.innerHTML = '';
            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Camera ${index + 1}`;
                if (device.label.toLowerCase().includes('back') || device.label.toLowerCase().includes('rear')) {
                    option.selected = true;
                }
                cameraSelect.appendChild(option);
            });
            
            if (videoDevices.length === 0) {
                cameraSelect.innerHTML = '<option value="">No cameras</option>';
                showStatus('No cameras available', 'error');
            } else {
                cameraStatus.textContent = 'Ready';
                statusDot.classList.remove('bg-slate-400');
                statusDot.classList.add('bg-yellow-400');
            }
        } catch (err) {
            console.error('Camera access error:', err);
            cameraSelect.innerHTML = '<option value="">Access denied</option>';
            showStatus('Please allow camera access', 'error');
        }
    }

    // Start camera
    async function startCamera() {
        try {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            const constraints = {
                video: {
                    deviceId: cameraSelect.value ? { exact: cameraSelect.value } : undefined,
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: cameraSelect.value ? undefined : 'environment'
                }
            };
            
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            videoPreview.srcObject = stream;
            cameraPlaceholder.classList.add('hidden');
            
            await new Promise(resolve => {
                videoPreview.onloadedmetadata = () => {
                    captureCanvas.width = videoPreview.videoWidth;
                    captureCanvas.height = videoPreview.videoHeight;
                    canvasOverlay.width = videoPreview.clientWidth;
                    canvasOverlay.height = videoPreview.clientHeight;
                    resolve();
                };
            });
            
            cameraStatus.textContent = 'Camera active';
            statusDot.classList.remove('bg-slate-400', 'bg-yellow-400');
            statusDot.classList.add('bg-green-500');
            return true;
        } catch (err) {
            console.error('Camera error:', err);
            cameraStatus.textContent = 'Camera error';
            statusDot.classList.remove('bg-green-500', 'bg-yellow-400');
            statusDot.classList.add('bg-red-500');
            showStatus('Failed to access camera: ' + err.message, 'error');
            return false;
        }
    }

    // Capture frame and send to server (NON-BLOCKING & ADAPTIVE)
    async function captureAndProcess() {
        if (!isScanning || !stream || isProcessing) return;
        
        isProcessing = true;
        const startTime = performance.now();
        
        try {
            ctx.drawImage(videoPreview, 0, 0, captureCanvas.width, captureCanvas.height);
            
            let sendCanvas = captureCanvas;
            if (captureCanvas.width > MAX_FRAME_WIDTH) {
                const ratio = MAX_FRAME_WIDTH / captureCanvas.width;
                const resizeCanvas = document.createElement('canvas');
                resizeCanvas.width = MAX_FRAME_WIDTH;
                resizeCanvas.height = Math.round(captureCanvas.height * ratio);
                resizeCanvas.getContext('2d').drawImage(captureCanvas, 0, 0, resizeCanvas.width, resizeCanvas.height);
                sendCanvas = resizeCanvas;
            }
            
            sentFrameWidth = sendCanvas.width;
            sentFrameHeight = sendCanvas.height;
            
            const frameData = sendCanvas.toDataURL('image/jpeg', FRAME_QUALITY);
            
            const response = await fetch('/api/process_frame', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ frame: frameData })
            });
            
            if (!response.ok) throw new Error('Server error');
            
            const result = await response.json();
            
            // Calculate total round-trip time
            const totalTime = performance.now() - startTime;
            lastProcessingTime = result.processing_time_ms || totalTime;
            
            // FAST: Simple adaptive interval
            currentInterval = Math.max(MIN_SCAN_INTERVAL_MS, Math.min(MAX_SCAN_INTERVAL_MS, lastProcessingTime + 100));
            
            // Quick status update
            cameraStatus.textContent = `${result.faces_detected} faces`;
            
            updateDetectionUI(result);
            drawFaceBoxes(result.faces || []);
            
        } catch (err) {
            console.error('Processing error:', err);
            currentInterval = MAX_SCAN_INTERVAL_MS;  // Slow down on error
        } finally {
            isProcessing = false;
            // Immediately schedule next frame
            if (isScanning) setTimeout(captureAndProcess, currentInterval);
        }
    }

    // Draw face detection boxes
    function drawFaceBoxes(faces) {
        overlayCtx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
        
        const scaleX = canvasOverlay.width / sentFrameWidth;
        const scaleY = canvasOverlay.height / sentFrameHeight;
        
        faces.forEach(face => {
            const x = face.left * scaleX;
            const y = face.top * scaleY;
            const w = (face.right - face.left) * scaleX;
            const h = (face.bottom - face.top) * scaleY;
            
            const isRecognized = face.recognized;
            const color = isRecognized ? '#22c55e' : '#ef4444';
            
            // Draw rounded box
            overlayCtx.strokeStyle = color;
            overlayCtx.lineWidth = 3;
            overlayCtx.beginPath();
            overlayCtx.roundRect(x, y, w, h, 8);
            overlayCtx.stroke();
            
            // Draw label
            const label = face.name + (face.confidence ? ` ${Math.round(face.confidence * 100)}%` : '');
            overlayCtx.font = 'bold 13px Inter, system-ui, sans-serif';
            const textWidth = overlayCtx.measureText(label).width;
            
            overlayCtx.fillStyle = color;
            overlayCtx.beginPath();
            overlayCtx.roundRect(x, y + h + 4, textWidth + 16, 24, 6);
            overlayCtx.fill();
            
            overlayCtx.fillStyle = '#ffffff';
            overlayCtx.fillText(label, x + 8, y + h + 20);
        });
    }

    // Update detection UI
    function updateDetectionUI(result) {
        detectedCount.textContent = result.session_count || 0;
        totalDetected.textContent = result.session_count || 0;
        
        if (result.students && result.students.length > 0) {
            detectedList.innerHTML = result.students.map(student => `
                <div class="student-card flex items-center justify-between p-4 bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-xl">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 rounded-full bg-green-500 flex items-center justify-center text-white font-bold">
                            ${student.name.charAt(0).toUpperCase()}
                        </div>
                        <div>
                            <div class="font-semibold text-slate-800">${student.name}</div>
                            <div class="text-sm text-slate-500">Roll #${student.roll_no}</div>
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-green-600 font-medium text-sm">‚úì Present</div>
                        <div class="text-xs text-slate-400">${student.time}</div>
                    </div>
                </div>
            `).join('');
        }
    }

    // Start scanning (ADAPTIVE - no fixed interval)
    startBtn.addEventListener('click', async () => {
        const cameraReady = await startCamera();
        if (!cameraReady) return;
        
        isScanning = true;
        isProcessing = false;
        currentInterval = BASE_SCAN_INTERVAL_MS;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        scanningBadge.classList.remove('hidden');
        cameraStatus.textContent = 'Scanning...';
        
        // Start adaptive scanning (captureAndProcess schedules itself)
        captureAndProcess();
        showStatus('Scanning started. Point camera at students.', 'success');
    });

    // Stop scanning
    stopBtn.addEventListener('click', () => {
        isScanning = false;
        isProcessing = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        scanningBadge.classList.add('hidden');
        cameraStatus.textContent = 'Paused';
        overlayCtx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
        showStatus('Scanning paused', 'info');
    });

    // Finalize attendance
    finalizeBtn.addEventListener('click', async () => {
        if (!confirm('Save attendance to database?')) return;
        
        try {
            const response = await fetch('/finalize_attendance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (response.ok) {
                showStatus(`‚úÖ Saved! Present: ${data.present_count}, Absent: ${data.absent_count}`, 'success');
                refreshSessionStatus();
            } else {
                showStatus(`‚ùå ${data.error}`, 'error');
            }
        } catch (err) {
            showStatus('Network error', 'error');
        }
    });

    // Reset session
    resetBtn.addEventListener('click', async () => {
        if (!confirm('Clear all detected students?')) return;
        
        try {
            const response = await fetch('/api/session/reset', { method: 'POST' });
            const data = await response.json();
            
            if (data.success || response.ok) {
                // Update counters immediately
                detectedCount.textContent = '0';
                totalDetected.textContent = '0';
                
                // Clear the list immediately
                detectedList.innerHTML = `
                    <div class="text-center py-8 text-slate-400">
                        <span class="text-4xl mb-2 block">üîç</span>
                        <p>No students detected yet</p>
                        <p class="text-sm mt-1">Start scanning to recognize faces</p>
                    </div>
                `;
                
                // Clear face overlay
                overlayCtx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
                
                showStatus('‚úì Session cleared - all students removed', 'success');
            } else {
                showStatus('Reset failed: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch (err) {
            console.error('Reset error:', err);
            showStatus('Reset failed - network error', 'error');
        }
    });

    // Refresh session status
    async function refreshSessionStatus() {
        try {
            const response = await fetch('/api/session/status');
            const data = await response.json();
            
            detectedCount.textContent = data.count || 0;
            totalDetected.textContent = data.count || 0;
            
            // Only update the list if there are students
            // This prevents overwriting the empty state message after reset
            if (data.count > 0 && data.students && data.students.length > 0) {
                detectedList.innerHTML = data.students.map(student => `
                    <div class="student-card flex items-center justify-between p-4 bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-xl">
                        <div class="flex items-center gap-3">
                            <div class="w-10 h-10 rounded-full bg-green-500 flex items-center justify-center text-white font-bold">
                                ${student.name.charAt(0).toUpperCase()}
                            </div>
                            <div>
                                <div class="font-semibold text-slate-800">${student.name}</div>
                                <div class="text-sm text-slate-500">Roll #${student.roll_no}</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="text-green-600 font-medium text-sm">‚úì Present</div>
                            <div class="text-xs text-slate-400">${student.time}</div>
                        </div>
                    </div>
                `).join('');
            } else if (data.count === 0) {
                // Show empty state when count is explicitly 0
                detectedList.innerHTML = `
                    <div class="text-center py-8 text-slate-400">
                        <span class="text-4xl mb-2 block">üîç</span>
                        <p>No students detected yet</p>
                        <p class="text-sm mt-1">Start scanning to recognize faces</p>
                    </div>
                `;
            }
        } catch (err) {
            console.error('Status refresh error:', err);
        }
    }

    // Show status message
    function showStatus(message, type) {
        statusMessage.classList.remove('hidden', 'bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700', 'bg-blue-100', 'text-blue-700');
        
        if (type === 'success') {
            statusMessage.classList.add('bg-green-100', 'text-green-700');
        } else if (type === 'error') {
            statusMessage.classList.add('bg-red-100', 'text-red-700');
        } else {
            statusMessage.classList.add('bg-blue-100', 'text-blue-700');
        }
        
        statusMessage.textContent = message;
        setTimeout(() => statusMessage.classList.add('hidden'), 5000);
    }

    // Camera change handler
    cameraSelect.addEventListener('change', () => {
        if (stream) startCamera();
    });

    // Handle page visibility - pause/resume scanning
    document.addEventListener('visibilitychange', () => {
        // When tab becomes hidden, just let the current scan finish
        // isScanning will prevent new scans from starting if false
        if (!document.hidden && isScanning && !isProcessing) {
            // Resume scanning when page becomes visible again
            captureAndProcess();
        }
    });

    // Initialize
    initCameraList();
    refreshSessionStatus();
    setInterval(refreshSessionStatus, 3000);
</script>
{% endblock %}
